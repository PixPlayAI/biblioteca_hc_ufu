// pages/api/search-mesh.js
import axios from 'axios';

// Usar DEEPSEEK_API_KEY ao inv√©s de OPENAI_API_KEY
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;
const MESH_API_KEY = process.env.MESH_API_KEY;
const NCBI_BASE_URL = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils';

// Verificar vari√°veis de ambiente no in√≠cio
if (!DEEPSEEK_API_KEY) {
  console.error('‚ö†Ô∏è AVISO: DEEPSEEK_API_KEY n√£o est√° configurada!');
}

// NOVO: Definir elementos v√°lidos por framework
const FRAMEWORK_ELEMENTS = {
  PICO: ['P', 'I', 'C', 'O'],
  PICOT: ['P', 'I', 'C', 'O', 'T'],
  PICOS: ['P', 'I', 'C', 'O', 'S'],
  PEO: ['P', 'E', 'O'],
  PECO: ['P', 'E', 'C', 'O'],
  PCC: ['P', 'C', 'C2'],
  SPIDER: ['S', 'PI', 'D', 'E', 'R'],
  PIRD: ['P', 'I', 'R', 'D'],
  CoCoPop: ['Co', 'Co2', 'Pop'],
  SPICE: ['S', 'P', 'I', 'C', 'E'],
  ECLIPSE: ['E', 'C', 'L', 'I', 'P', 'SE'],
  BeHEMoTh: ['Be', 'HE', 'Mo', 'Th'],
};

// NOVO: Fun√ß√£o para filtrar apenas elementos v√°lidos do framework
function filterValidFrameworkElements(frameworkElements, frameworkType) {
  const validElements = FRAMEWORK_ELEMENTS[frameworkType];
  if (!validElements) {
    console.warn(`Framework n√£o reconhecido: ${frameworkType}`);
    return frameworkElements;
  }

  const filtered = {};
  Object.entries(frameworkElements).forEach(([key, value]) => {
    if (validElements.includes(key)) {
      filtered[key] = value;
    } else {
      console.warn(`Elemento "${key}" n√£o √© v√°lido para o framework ${frameworkType}. Ignorando.`);
    }
  });

  return filtered;
}

// Fun√ß√£o para gerar o prompt com tratamento de erro
function generatePrompt(frameworkElements, fullQuestion, frameworkType) {
  try {
    // Defini√ß√µes base por framework
    const frameworkDefinitions = {
      PICO: `PICO - Framework para quest√µes cl√≠nicas sobre interven√ß√µes:
- P (Population/Patient): Popula√ß√£o espec√≠fica ou pacientes com condi√ß√£o cl√≠nica
- I (Intervention): Tratamento, terapia, medicamento ou procedimento ATIVO
- C (Comparison): Grupo controle, placebo ou tratamento alternativo
- O (Outcome): Desfecho cl√≠nico mensur√°vel`,
      
      PICOT: `PICOT - PICO com elemento temporal:
- P (Population/Patient): Popula√ß√£o espec√≠fica ou pacientes
- I (Intervention): Interven√ß√£o terap√™utica ativa
- C (Comparison): Comparador ou controle
- O (Outcome): Desfecho mensur√°vel
- T (Time): Per√≠odo de seguimento/acompanhamento (6 meses, 1 ano, etc.)`,
      
      PICOS: `PICOS - PICO com desenho do estudo:
- P (Population/Patient): Popula√ß√£o do estudo
- I (Intervention): Interven√ß√£o avaliada
- C (Comparison): Comparador
- O (Outcome): Desfecho
- S (Study Design): Tipo de estudo (RCT, coorte, caso-controle)`,
      
      PEO: `PEO - Framework para estudos observacionais sem compara√ß√£o:
- P (Population): Popula√ß√£o exposta
- E (Exposure): Exposi√ß√£o NATURAL/OCUPACIONAL (n√£o controlada)
- O (Outcome): Desfecho observado`,
      
      PECO: `PECO - PEO com compara√ß√£o de exposi√ß√µes:
- P (Population): Popula√ß√£o do estudo
- E (Exposure): Exposi√ß√£o natural/ambiental/ocupacional
- C (Comparison): Grupo n√£o exposto ou diferente exposi√ß√£o
- O (Outcome): Desfecho observado`,
      
      PCC: `PCC - Framework para revis√µes de escopo:
- P (Population): Popula√ß√£o de interesse
- C (Concept): Conceito/fen√¥meno central explorado
- C2 (Context): Contexto geogr√°fico/cultural/temporal`,
      
      SPIDER: `SPIDER - Framework para pesquisa qualitativa:
- S (Sample): Amostra espec√≠fica do estudo
- PI (Phenomenon of Interest): Experi√™ncia/percep√ß√£o/viv√™ncia estudada
- D (Design): M√©todo qualitativo (entrevistas, grupos focais)
- E (Evaluation): O que est√° sendo avaliado/analisado
- R (Research Type): Tipo de pesquisa qualitativa`,
      
      PIRD: `PIRD - Framework para estudos diagn√≥sticos:
- P (Population): Popula√ß√£o com suspeita diagn√≥stica
- I (Index Test): Novo teste diagn√≥stico em avalia√ß√£o
- R (Reference Test): Teste padr√£o-ouro para compara√ß√£o
- D (Diagnosis): Condi√ß√£o sendo diagnosticada`,
      
      CoCoPop: `CoCoPop - Framework para estudos de preval√™ncia:
- Co (Condition): Doen√ßa/condi√ß√£o de sa√∫de espec√≠fica
- Co2 (Context): Contexto temporal/geogr√°fico/social
- Pop (Population): Popula√ß√£o onde se mede preval√™ncia`,
      
      SPICE: `SPICE - Framework para avalia√ß√£o de servi√ßos:
- S (Setting): Local/ambiente do servi√ßo de sa√∫de
- P (Perspective): De quem √© a perspectiva (usu√°rios, profissionais)
- I (Intervention): Mudan√ßa/implementa√ß√£o no servi√ßo
- C (Comparison): Pr√°tica atual/tradicional
- E (Evaluation): Indicadores de qualidade/satisfa√ß√£o`,
      
      ECLIPSE: `ECLIPSE - Framework para pol√≠ticas de sa√∫de:
- E (Expectation): Objetivo/meta da pol√≠tica
- C (Client Group): Grupo benefici√°rio
- L (Location): Local/regi√£o de implementa√ß√£o
- I (Impact): Impacto organizacional esperado
- P (Professionals): Profissionais envolvidos
- SE (Service): Tipo de servi√ßo de sa√∫de`,
      
      BeHEMoTh: `BeHEMoTh - Framework para comportamento em sa√∫de:
- Be (Behavior): Comportamento de sa√∫de espec√≠fico
- HE (Health Context): Contexto/ambiente de sa√∫de
- Mo (Exclusions): Exclus√µes metodol√≥gicas
- Th (Models/Theories): Teorias comportamentais aplicadas`
    };

    // Exemplos por framework com foco em abstra√ß√µes dif√≠ceis
    const frameworkExamples = {
      PICO: `Exemplo PICO - "Em adultos obesos (P), dieta low-carb (I) vs dieta low-fat (C) para perda de peso (O)":
{
  "P": ["adults", "obesity", "obese", "overweight", "adult"],
  "I": ["diet, carbohydrate-restricted", "low carbohydrate diet", "ketogenic diet", "carbohydrate restriction", "diet therapy"],
  "C": ["diet, fat-restricted", "low fat diet", "lipid restriction", "dietary fats", "fat intake"],
  "O": ["weight loss", "body weight", "weight reduction", "body mass index", "obesity management"]
}`,
      
      PEO: `Exemplo PEO - "Mulheres gr√°vidas (P) expostas a fumo passivo (E) e baixo peso ao nascer (O)":
{
  "P": ["pregnant women", "pregnancy", "maternal", "expectant mothers", "gestation"],
  "E": ["tobacco smoke pollution", "passive smoking", "secondhand smoke", "environmental tobacco smoke", "smoke exposure"],
  "O": ["infant, low birth weight", "birth weight", "fetal growth retardation", "small for gestational age", "neonatal weight"]
}`,
      
      SPIDER: `Exemplo SPIDER - "Enfermeiras rec√©m-graduadas (S) experi√™ncia primeira semana (PI) entrevistas (D) impacto psicol√≥gico (E) qualitativa (R)":
{
  "S": ["nurses", "nursing staff", "new graduate nurses", "novice nurses", "nursing personnel"],
  "PI": ["professional adaptation", "work experience", "transition to practice", "first week experience", "workplace adjustment"],
  "D": ["interviews", "qualitative research", "semi-structured interviews", "interview methods", "data collection"],
  "E": ["psychological impact", "stress, psychological", "adaptation, psychological", "emotional adjustment", "mental health"],
  "R": ["qualitative research", "phenomenology", "descriptive study", "interpretive research", "narrative analysis"]
}`,
      
      PIRD: `Exemplo PIRD - "Suspeita infarto (P), troponina point-of-care (I) vs ECG+troponina lab (R) para diagn√≥stico IAM (D)":
{
  "P": ["myocardial infarction", "acute coronary syndrome", "chest pain", "emergency service", "suspected MI"],
  "I": ["troponin", "point-of-care testing", "rapid diagnostics", "bedside testing", "troponin test"],
  "R": ["electrocardiography", "troponin", "laboratory techniques", "standard diagnosis", "conventional testing"],
  "D": ["myocardial infarction", "acute myocardial infarction", "heart attack", "cardiac diagnosis", "MI diagnosis"]
}`,

      SPICE: `Exemplo SPICE - "Hospital (S), perspectiva dos pacientes (P), implementa√ß√£o de agendamento online (I) vs agendamento presencial (C), satisfa√ß√£o do usu√°rio (E)":
{
  "S": ["hospitals", "health facilities", "medical center", "healthcare setting", "outpatient clinics"],
  "P": ["patients", "patient satisfaction", "patient perspective", "health care consumers", "service users"],
  "I": ["appointments and schedules", "telemedicine", "mobile applications", "online systems", "digital health"],
  "C": ["traditional practice", "conventional methods", "standard care", "usual practice", "routine procedures"],
  "E": ["patient satisfaction", "waiting time", "access to health care", "quality indicators", "service quality"]
}`
    };

    const prompt = `Voc√™ √© um especialista em extra√ß√£o de conceitos m√©dicos para busca na base de dados MeSH (Medical Subject Headings). Sua tarefa √© analisar elementos de frameworks de pesquisa e extrair conceitos que REALMENTE EXISTEM no vocabul√°rio MeSH.

üéØ FRAMEWORK ATUAL: ${frameworkType}

üìö DEFINI√á√ÉO ESPEC√çFICA DOS ELEMENTOS POR FRAMEWORK:

${frameworkDefinitions[frameworkType] || 'Framework n√£o definido'}

‚ö†Ô∏è REGRAS CR√çTICAS DE RELEV√ÇNCIA:

1. RELEV√ÇNCIA ABSOLUTA: Cada conceito DEVE estar DIRETAMENTE relacionado ao elemento espec√≠fico
   - Para P: apenas termos sobre a popula√ß√£o descrita
   - Para I: apenas termos sobre a interven√ß√£o mencionada
   - Para C: apenas termos sobre o comparador
   - Para O: apenas termos sobre o desfecho
   - E assim por diante para cada elemento

2. PROIBIDO MISTURAR ELEMENTOS:
   ‚ùå N√ÉO coloque conceitos de interven√ß√£o no elemento Popula√ß√£o
   ‚ùå N√ÉO coloque conceitos de desfecho no elemento Interven√ß√£o
   ‚ùå N√ÉO misture conceitos entre elementos diferentes

3. VALIDA√á√ÉO DE RELEV√ÇNCIA:
   Antes de incluir um conceito, pergunte-se:
   - "Este termo est√° REALMENTE relacionado ao elemento?"
   - "Este termo aparece na descri√ß√£o fornecida?"
   - "Este termo faz sentido para o tipo de elemento no framework ${frameworkType}?"

üîç EXEMPLOS ESPEC√çFICOS POR FRAMEWORK:

${frameworkExamples[frameworkType] || ''}

üìã ESTRAT√âGIA DE DECOMPOSI√á√ÉO E ABSTRA√á√ÉO:

1. CONCEITOS COMPOSTOS: Sempre separe e abstraia
   - "adultos obesos" ‚Üí ["adults", "obesity", "obese", "overweight", "adult"]
   - "idosos diab√©ticos" ‚Üí ["aged", "diabetes mellitus", "elderly", "diabetic", "geriatrics"]
   - "agendamento online" ‚Üí ["appointments and schedules", "online systems", "internet", "scheduling", "telemedicine"]
   - "aplicativo m√≥vel" ‚Üí ["mobile applications", "smartphone", "mHealth", "cell phone", "mobile health"]

2. TECNOLOGIA E INOVA√á√ÉO: Abstraia para conceitos MeSH existentes
   - "agendamento online via aplicativo" ‚Üí ["appointments and schedules", "telemedicine", "mobile applications", "internet", "patient portals"]
   - "sistema digital" ‚Üí ["medical informatics", "computerized systems", "electronic health records", "health information systems"]
   - "presencial tradicional" ‚Üí ["office visits", "traditional practice", "standard care", "conventional therapy", "routine procedures"]

3. ESPECIFICIDADE GRADUAL: Do espec√≠fico ao geral
   - Espec√≠fico: "diabetes mellitus, type 2"
   - M√©dio: "diabetes mellitus"
   - Geral: "metabolic diseases"

4. CONCEITOS ABSTRATOS: Traduza para termos MeSH
   - "satisfa√ß√£o do usu√°rio" ‚Üí ["patient satisfaction", "consumer satisfaction", "quality of health care", "patient preference", "treatment satisfaction"]
   - "tempo de espera" ‚Üí ["waiting lists", "time factors", "appointment wait time", "health services accessibility", "time-to-treatment"]
   - "melhora" ‚Üí ["improvement", "treatment outcome", "quality improvement", "health care quality", "outcome assessment"]

5. SIN√îNIMOS MeSH: Inclua varia√ß√µes aceitas
   - Para tecnologia: ["telemedicine", "eHealth", "mHealth", "digital health", "health information technology"]
   - Para satisfa√ß√£o: ["patient satisfaction", "consumer satisfaction", "patient experience", "quality of care", "patient-centered care"]

‚ùå ERROS COMUNS A EVITAR:

1. TERMOS MUITO ESPEC√çFICOS SEM MESH:
   ‚ùå "agendamento online via WhatsApp"
   ‚úÖ "appointments and schedules", "mobile applications", "instant messaging"

2. CONCEITOS FORA DO ESCOPO:
   ‚ùå Colocar "exercise" em P quando P descreve apenas "adultos obesos"
   ‚úÖ Manter apenas conceitos sobre obesidade e adultos

3. GENERALIZA√á√ÉO EXCESSIVA:
   ‚ùå Usar apenas "disease" quando a condi√ß√£o √© "diabetes tipo 2"
   ‚úÖ Usar termos espec√≠ficos: "diabetes mellitus, type 2"

4. INVENTAR RELA√á√ïES:
   ‚ùå Adicionar "treatment outcome" em P s√≥ porque √© um estudo cl√≠nico
   ‚úÖ Adicionar apenas se O realmente menciona outcomes

5. IGNORAR TECNOLOGIA:
   ‚ùå N√£o abstrair "aplicativo m√≥vel" por ser muito moderno
   ‚úÖ Usar "mobile applications", "mHealth", "smartphone", "telemedicine"

üéØ ELEMENTOS A PROCESSAR:
${JSON.stringify(frameworkElements, null, 2)}

üìù PERGUNTA COMPLETA PARA CONTEXTO:
${fullQuestion}

üö® FORMATO DE RETORNO OBRIGAT√ìRIO:

Retorne EXATAMENTE um objeto JSON com:
- As MESMAS chaves fornecidas em frameworkElements
- Cada chave com array de 5-7 termos MeSH relevantes (AUMENTADO para melhor cobertura)
- Termos APENAS em ingl√™s
- Termos que EXISTEM no MeSH ou s√£o abstra√ß√µes v√°lidas
- Conceitos DIRETAMENTE relacionados ao elemento
- Para conceitos modernos/tecnol√≥gicos, use abstra√ß√µes MeSH apropriadas

VALIDA√á√ÉO FINAL antes de retornar:
‚úì Cada conceito est√° relacionado ao seu elemento?
‚úì Evitei misturar conceitos entre elementos?
‚úì Usei termos MeSH em ingl√™s?
‚úì Tenho 5-7 termos por elemento?
‚úì Abstra√≠ conceitos modernos para termos MeSH existentes?
‚úì O JSON est√° v√°lido?

RETORNE APENAS O JSON, SEM EXPLICA√á√ïES.`;

    return prompt;
  } catch (error) {
    console.error('‚ùå Erro ao gerar prompt:', error);
    throw error;
  }
}

// Fun√ß√£o aprimorada para extrair conceitos usando DeepSeek
async function extractConcepts(frameworkElements, fullQuestion, frameworkType) {
  console.log('ü§ñ extractConcepts - IN√çCIO da extra√ß√£o de conceitos com DeepSeek');
  console.log('üìã Framework Type:', frameworkType);
  console.log('‚ùì Pergunta completa:', fullQuestion);
  console.log('üìä Elementos do framework recebidos:', frameworkElements);
  
  // LOG DETALHADO DE CADA ELEMENTO RECEBIDO
  console.log('\nüîç DETALHAMENTO DOS ELEMENTOS RECEBIDOS:');
  console.log('=====================================');
  Object.entries(frameworkElements).forEach(([elemento, descricao]) => {
    console.log(`üìå ${elemento}: "${descricao}"`);
  });
  console.log('=====================================\n');
  
  // Usar a nova fun√ß√£o generatePrompt
  const prompt = generatePrompt(frameworkElements, fullQuestion, frameworkType);
  console.log('üì§ Enviando prompt otimizado para DeepSeek');

  try {
    const response = await axios.post(
      'https://api.deepseek.com/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { 
            role: 'system', 
            content: 'Voc√™ √© um especialista em extra√ß√£o de conceitos m√©dicos para busca em bases de dados. Voc√™ extrai termos simples e diretos que existem no MeSH ou s√£o abstra√ß√µes v√°lidas. SEMPRE processe TODOS os elementos fornecidos com 5-7 conceitos cada. Para conceitos modernos ou tecnol√≥gicos, use abstra√ß√µes apropriadas do MeSH. NUNCA retorne arrays vazios ou com menos de 5 conceitos.' 
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.1, // Reduzido para mais consist√™ncia
        max_tokens: 2000,
        response_format: { type: "json_object" }
      },
      {
        headers: {
          'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 59000 // 59 segundos de timeout
      }
    );

    const concepts = JSON.parse(response.data.choices[0].message.content);
    
    console.log('\n‚úÖ CONCEITOS EXTRA√çDOS PELA IA (DeepSeek):');
    console.log('================================');
    console.log(JSON.stringify(concepts, null, 2));
    console.log('================================\n');
    
    // VERIFICAR SE TODOS OS ELEMENTOS FORAM PROCESSADOS
    const elementosNaoProcessados = Object.keys(frameworkElements).filter(
      elem => !concepts[elem] || concepts[elem].length === 0
    );
    
    if (elementosNaoProcessados.length > 0) {
      console.error('‚ùå ERRO: Elementos n√£o processados pela IA:', elementosNaoProcessados);
      
      // Adicionar conceitos de fallback mais inteligentes
      elementosNaoProcessados.forEach(elem => {
        const texto = frameworkElements[elem];
        if (texto) {
          // Estrat√©gia de fallback mais inteligente
          concepts[elem] = generateFallbackConcepts(texto, elem, frameworkType);
          console.log(`üîß Adicionando conceitos de fallback para ${elem}: ${JSON.stringify(concepts[elem])}`);
        }
      });
    }
    
    // GARANTIR QUE CADA ELEMENTO TENHA PELO MENOS 5 CONCEITOS
    Object.entries(concepts).forEach(([elem, termos]) => {
      if (termos.length < 5) {
        console.warn(`‚ö†Ô∏è Elemento ${elem} tem apenas ${termos.length} conceitos. Expandindo...`);
        const textoOriginal = frameworkElements[elem];
        
        // Adicionar mais conceitos relacionados
        const additionalConcepts = generateAdditionalConcepts(textoOriginal, elem, frameworkType);
        concepts[elem] = [...new Set([...termos, ...additionalConcepts])].slice(0, 7);
      }
    });
    
    // LOG SUPER DETALHADO - COMPARA√á√ÉO ENTRADA VS SA√çDA
    console.log('\nüîÑ COMPARA√á√ÉO ENTRADA ‚Üí SA√çDA (POR ELEMENTO):');
    console.log('==============================================');
    Object.entries(frameworkElements).forEach(([elemento, descricao]) => {
      const termos = concepts[elemento] || [];
      console.log(`\nüìå Elemento: ${elemento}`);
      console.log(`   üì• ENTRADA (Descri√ß√£o original): "${descricao}"`);
      console.log(`   üì§ SA√çDA (Conceitos extra√≠dos): ${JSON.stringify(termos)}`);
      console.log(`   üìä Quantidade de conceitos: ${termos.length}`);
      
      if (termos.length > 0) {
        console.log('   üìù Detalhamento dos conceitos:');
        termos.forEach((termo, index) => {
          console.log(`      ${index + 1}. "${termo}"`);
        });
      }
    });
    console.log('==============================================\n');
    
    console.log('ü§ñ extractConcepts - FIM da extra√ß√£o');
    
    return concepts;
  } catch (error) {
    console.error('‚ùå Erro ao extrair conceitos com DeepSeek:', error);
    console.error('‚ùå Detalhes do erro:', error.response?.data);
    
    // Fallback completo se a IA falhar
    console.log('üîß Aplicando fallback completo...');
    const fallbackConcepts = {};
    Object.entries(frameworkElements).forEach(([elem, texto]) => {
      fallbackConcepts[elem] = generateFallbackConcepts(texto, elem, frameworkType);
    });
    
    return fallbackConcepts;
  }
}

// Nova fun√ß√£o para gerar conceitos de fallback inteligentes
function generateFallbackConcepts(text, element, frameworkType) {
  const concepts = [];
  const lowerText = text.toLowerCase();
  
  // Conceitos b√°sicos baseados no texto
  concepts.push(text);
  
  // Mapeamento de conceitos comuns para MeSH
  const conceptMappings = {
    // Tecnologia
    'online': ['telemedicine', 'internet', 'computers', 'online systems'],
    'aplicativo': ['mobile applications', 'smartphone', 'cell phone', 'software'],
    'm√≥vel': ['mobile health', 'mHealth', 'portable electronic applications'],
    'digital': ['digital health', 'electronic health records', 'computerized'],
    'sistema': ['information systems', 'computer systems', 'software'],
    'agendamento': ['appointments and schedules', 'scheduling', 'time management'],
    
    // M√©todos tradicionais
    'presencial': ['office visits', 'face-to-face', 'ambulatory care'],
    'tradicional': ['standard therapy', 'conventional treatment', 'usual care'],
    
    // Outcomes
    'satisfa√ß√£o': ['patient satisfaction', 'consumer satisfaction', 'quality of care'],
    'tempo': ['time factors', 'waiting time', 'time-to-treatment'],
    'espera': ['waiting lists', 'appointment wait time', 'access delay'],
    'melhora': ['improvement', 'treatment outcome', 'health care quality'],
    'reduz': ['reduction', 'decrease', 'minimization'],
    
    // Popula√ß√µes
    'usu√°rio': ['patients', 'health care consumers', 'service users'],
    'paciente': ['patients', 'outpatients', 'ambulatory patients'],
    
    // Servi√ßos
    'consulta': ['office visits', 'medical consultation', 'ambulatory care'],
    'marca√ß√£o': ['appointments', 'scheduling', 'booking']
  };
  
  // Adicionar conceitos baseados em palavras-chave
  Object.entries(conceptMappings).forEach(([keyword, meshTerms]) => {
    if (lowerText.includes(keyword)) {
      concepts.push(...meshTerms);
    }
  });
  
  // Adicionar conceitos espec√≠ficos por tipo de elemento
  if (frameworkType === 'SPICE') {
    switch(element) {
      case 'I':
        concepts.push('health care reform', 'organizational innovation', 'quality improvement');
        break;
      case 'C':
        concepts.push('comparative study', 'control groups', 'reference standards');
        break;
      case 'E':
        concepts.push('outcome assessment', 'program evaluation', 'health care evaluation');
        break;
    }
  }
  
  // Remover duplicatas e limitar a 7 conceitos
  return [...new Set(concepts)].slice(0, 7);
}

// Nova fun√ß√£o para gerar conceitos adicionais
function generateAdditionalConcepts(text, element, frameworkType) {
  const concepts = [];
  
  // Adicionar conceitos gen√©ricos relacionados
  concepts.push(
    'health services',
    'health care delivery',
    'health care quality',
    'health services accessibility',
    'patient care'
  );
  
  return concepts;
}

// Fun√ß√£o para buscar termos MeSH SEM LIMITES
async function searchMeSHTerm(term) {
  console.log(`\nüîç searchMeSHTerm - Buscando termo: "${term}"`);
  
  const debugInfo = {
    searchTerm: term,
    apiCalls: [],
    usingApiKey: !!MESH_API_KEY
  };

  try {
    // Delay m√°ximo entre requisi√ß√µes
    await new Promise(resolve => setTimeout(resolve, 1000)); // 1 segundo de delay
    
    // Busca o ID do termo SEM LIMITE
    const searchUrl = `${NCBI_BASE_URL}/esearch.fcgi`;
    const searchParams = {
      db: 'mesh',
      term: term,
      retmode: 'json',
      retmax: 1000, // Buscar at√© 1000 resultados
      ...(MESH_API_KEY && { api_key: MESH_API_KEY })
    };
    
    debugInfo.apiCalls.push({
      type: 'search',
      url: searchUrl,
      params: searchParams,
      hasApiKey: !!MESH_API_KEY
    });

    console.log(`   üì° Chamando NCBI E-utilities...`);
    
    const searchResponse = await axios.get(searchUrl, { 
      params: searchParams,
      timeout: 59000 // 59 segundos de timeout
    });
    
    debugInfo.apiCalls[0].response = {
      count: searchResponse.data.esearchresult.count,
      ids: searchResponse.data.esearchresult.idlist
    };

    console.log(`   üìä Resultados encontrados: ${searchResponse.data.esearchresult.count}`);

    const ids = searchResponse.data.esearchresult.idlist;
    if (!ids || ids.length === 0) {
      console.log(`   ‚ö†Ô∏è Nenhum resultado encontrado`);
      debugInfo.noResultsFound = true;
      return { results: [], debug: debugInfo };
    }

    // Busca detalhes de TODOS os termos
    const summaryUrl = `${NCBI_BASE_URL}/esummary.fcgi`;
    const summaryParams = {
      db: 'mesh',
      id: ids.join(','),
      retmode: 'json',
      ...(MESH_API_KEY && { api_key: MESH_API_KEY })
    };

    debugInfo.apiCalls.push({
      type: 'summary',
      url: summaryUrl,
      params: summaryParams,
      hasApiKey: !!MESH_API_KEY
    });

    const summaryResponse = await axios.get(summaryUrl, { 
      params: summaryParams,
      timeout: 59000 // 59 segundos de timeout
    });
    
    const results = [];
    const uids = summaryResponse.data.result.uids || [];
    
    console.log(`   üìã Processando ${uids.length} termos MeSH`);
    
    for (const uid of uids) {
      const meshData = summaryResponse.data.result[uid];
      if (!meshData || meshData.error) continue;
      
      // Extrair TODOS os dados
      const preferredTerm = meshData.ds_meshui || meshData.ds_meshterms?.[0] || '';
      const meshTerms = meshData.ds_meshterms || [];
      
      // Extrair TODOS os tree numbers
      let treeNumbers = [];
      
      if (meshData.ds_meshhierarchy && Array.isArray(meshData.ds_meshhierarchy)) {
        treeNumbers = meshData.ds_meshhierarchy.filter(h => typeof h === 'string');
      }
      
      if (treeNumbers.length === 0 && meshData.ds_idxlinks) {
        if (Array.isArray(meshData.ds_idxlinks)) {
          treeNumbers = meshData.ds_idxlinks.map(link => {
            if (typeof link === 'string') return link;
            
            if (typeof link === 'object' && link !== null) {
              if (link.parent) return link.parent;
              if (link.code) return link.code;
              if (link.treeNumber) return link.treeNumber;
              if (link.hierarchyCode) return link.hierarchyCode;
              if (link.descriptor) return link.descriptor;
              
              for (const [key, value] of Object.entries(link)) {
                if (typeof value === 'string' && /^[A-Z]\d+/.test(value)) {
                  return value;
                }
              }
              
              return null;
            }
            
            return null;
          }).filter(Boolean);
        }
      }
      
      // TODOS os sin√¥nimos
      const synonyms = meshData.ds_meshsynonyms || [];
      
      // Defini√ß√£o COMPLETA
      const definition = meshData.ds_scopenote || '';
      
      // Calcular relevance score com degrada√ß√£o mais suave
      const relevanceScore = Math.round(95 - (results.length * 0.3));
      
      const result = {
        meshId: uid,
        meshUI: preferredTerm,
        term: meshTerms[0] || term,
        allTerms: meshTerms,
        definition: definition,
        synonyms: synonyms,
        treeNumbers: treeNumbers,
        relevanceScore: relevanceScore
      };
      
      results.push(result);
    }

    console.log(`   ‚úÖ ${results.length} termos MeSH processados`);

    return { results, debug: debugInfo };
  } catch (error) {
    console.error(`   ‚ùå Erro ao buscar MeSH:`, error.message);
    debugInfo.error = error.message;
    return { results: [], debug: debugInfo };
  }
}

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // Configurar headers
  res.setHeader('Content-Type', 'application/json; charset=utf-8');

  console.log('\nüöÄ API MeSH - IN√çCIO DO PROCESSAMENTO');
  console.log('===================================================');
  console.log('üì• Dados recebidos:', JSON.stringify(req.body, null, 2));

  const { frameworkElements, fullQuestion, frameworkType } = req.body;

  // Filtrar elementos v√°lidos
  const validFrameworkElements = filterValidFrameworkElements(frameworkElements, frameworkType);
  console.log('‚úÖ Elementos v√°lidos:', validFrameworkElements);

  try { 
    const processStartTime = Date.now();
    
    // Debug completo do processo
    const fullDebug = {
      'üöÄ IN√çCIO': new Date().toISOString(),
      'üìù ENTRADA ORIGINAL': {
        frameworkElements,
        fullQuestion,
        frameworkType
      },
      'üîë API KEY STATUS': MESH_API_KEY ? 'CONFIGURADA' : 'N√ÉO CONFIGURADA',
      'üîÑ PROCESSO': []
    };

    // PASSO 1: Extrair conceitos usando IA
    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('ü§ñ PASSO 1: EXTRA√á√ÉO DE CONCEITOS COM IA');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    const concepts = await extractConcepts(validFrameworkElements, fullQuestion, frameworkType);
    
    console.log('\nüîç CONCEITOS EXTRA√çDOS POR ELEMENTO:');
    Object.entries(concepts).forEach(([elem, terms]) => {
      console.log(`${elem}: ${terms.length} conceitos - ${JSON.stringify(terms)}`);
    });
    
    // PASSO 2: Buscar termos MeSH para CADA conceito
    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üîé PASSO 2: BUSCA DE TERMOS MESH');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    const results = [];
    const allMeshTerms = [];
    
    // PROCESSAR CADA ELEMENTO SEQUENCIALMENTE
    for (const [element, originalText] of Object.entries(validFrameworkElements)) {
      console.log(`\nüìå PROCESSANDO ELEMENTO: ${element} - "${originalText}"`);
      
      const elementResults = {
        element,
        originalText: originalText,
        terms: []
      };
      
      // Obter conceitos para este elemento
      const elementConcepts = concepts[element] || [];
      
      if (elementConcepts.length === 0) {
        console.log(`‚ö†Ô∏è Nenhum conceito extra√≠do, tentando buscar com texto original`);
        
        // Tentar buscar com o texto original
        if (originalText && originalText.trim()) {
          console.log(`üîç Buscando com texto original: "${originalText}"`);
          const { results: meshTerms } = await searchMeSHTerm(originalText);
          
          // Adicionar termos com score >= 50%
          meshTerms.forEach(meshTerm => {
            if (meshTerm.relevanceScore >= 50) {
              const cleanTerm = { ...meshTerm };
              delete cleanTerm._rawData;
              
              elementResults.terms.push(cleanTerm);
              allMeshTerms.push(cleanTerm);
              console.log(`   ‚úÖ Termo adicionado: "${meshTerm.term}" (${meshTerm.relevanceScore}%)`);
            }
          });
        }
      } else {
        console.log(`üîç ${elementConcepts.length} conceitos para buscar: ${JSON.stringify(elementConcepts)}`);
        
        // Buscar TODOS os conceitos
        for (let i = 0; i < elementConcepts.length; i++) {
          const searchTerm = elementConcepts[i];
          console.log(`\n   [${i+1}/${elementConcepts.length}] Buscando: "${searchTerm}"`);
          
          try {
            const { results: meshTerms } = await searchMeSHTerm(searchTerm);
            
            let addedCount = 0;
            meshTerms.forEach(meshTerm => {
              if (meshTerm.relevanceScore >= 50) {
                const cleanTerm = { ...meshTerm };
                delete cleanTerm._rawData;
                
                // Verificar se j√° n√£o foi adicionado
                if (!elementResults.terms.find(t => t.meshId === meshTerm.meshId)) {
                  elementResults.terms.push(cleanTerm);
                  allMeshTerms.push(cleanTerm);
                  addedCount++;
                }
              }
            });
            
            console.log(`   ‚úÖ ${addedCount} termos adicionados (score >= 50%)`);
          } catch (error) {
            console.error(`   ‚ùå Erro ao buscar "${searchTerm}":`, error.message);
          }
        }
      }
      
      // Ordenar por relev√¢ncia
      elementResults.terms.sort((a, b) => b.relevanceScore - a.relevanceScore);
      
      // Adicionar resultado do elemento
      results.push(elementResults);
      
      console.log(`\n‚úÖ ELEMENTO ${element} CONCLU√çDO: ${elementResults.terms.length} termos MeSH encontrados`);
    }

    // Remover duplicatas globais
    const uniqueMeshTerms = allMeshTerms
      .filter((term, index, self) => index === self.findIndex(t => t.meshId === term.meshId))
      .filter(term => term.relevanceScore >= 50);

    const processTime = Date.now() - processStartTime;
    
    // LOG FINAL
    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä RESUMO FINAL DO PROCESSAMENTO');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`‚è±Ô∏è Tempo total: ${processTime}ms (${(processTime/1000).toFixed(2)}s)`);
    console.log(`‚úÖ Elementos processados: ${results.length}`);
    console.log('\nüìã RESUMO POR ELEMENTO:');
    results.forEach((r) => {
      console.log(`${r.element}: ${r.terms.length} termos MeSH`);
      if (r.terms.length > 0) {
        console.log(`   Top 3: ${r.terms.slice(0, 3).map(t => `"${t.term}" (${t.relevanceScore}%)`).join(', ')}`);
      }
    });
    console.log(`\nüéØ Total de termos √∫nicos: ${uniqueMeshTerms.length}`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

    // Preparar resposta
    const responseData = {
      results, 
      allMeshTerms: uniqueMeshTerms,
      debug: process.env.NODE_ENV === 'development' ? fullDebug : undefined
    };
    
    console.log('üì§ Enviando resposta...');
    res.status(200).json(responseData);
  } catch (error) {
    console.error('‚ùå ERRO GERAL:', error);
    res.status(500).json({ 
      error: 'Erro ao buscar termos MeSH',
      details: error.message
    });
  }
}