// pages/api/search-decs.js
import axios from 'axios';

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;
const DECS_API_KEY = process.env.DECS_API_KEY;
const DECS_BASE_URL = 'https://api.bvsalud.org/decs/v2';

// Mapeamento de elementos v√°lidos por framework (mesmo do MeSH)
const FRAMEWORK_ELEMENTS = {
  PICO: ['P', 'I', 'C', 'O'],
  PICOT: ['P', 'I', 'C', 'O', 'T'],
  PICOS: ['P', 'I', 'C', 'O', 'S'],
  PEO: ['P', 'E', 'O'],
  PECO: ['P', 'E', 'C', 'O'],
  PCC: ['P', 'C', 'C2'],
  SPIDER: ['S', 'PI', 'D', 'E', 'R'],
  PIRD: ['P', 'I', 'R', 'D'],
  CoCoPop: ['Co', 'Co2', 'Pop'],
  SPICE: ['S', 'P', 'I', 'C', 'E'],
  ECLIPSE: ['E', 'C', 'L', 'I', 'P', 'SE'],
  BeHEMoTh: ['Be', 'HE', 'Mo', 'Th'],
};

// Fun√ß√£o para filtrar elementos v√°lidos do framework
function filterValidFrameworkElements(frameworkElements, frameworkType) {
  const validElements = FRAMEWORK_ELEMENTS[frameworkType];
  if (!validElements) {
    console.warn(`Framework n√£o reconhecido: ${frameworkType}`);
    return frameworkElements;
  }

  const filtered = {};
  Object.entries(frameworkElements).forEach(([key, value]) => {
    if (validElements.includes(key)) {
      filtered[key] = value;
    }
  });

  return filtered;
}

// Fun√ß√£o para gerar prompt similar ao MeSH mas adaptado para DeCS
function generatePrompt(frameworkElements, fullQuestion, frameworkType) {
  const frameworkDefinitions = {
    PICO: `PICO - Framework para quest√µes cl√≠nicas:
- P (Popula√ß√£o/Paciente): Popula√ß√£o espec√≠fica ou pacientes
- I (Interven√ß√£o): Tratamento, terapia ou procedimento
- C (Compara√ß√£o): Grupo controle ou tratamento alternativo
- O (Desfecho): Resultado cl√≠nico mensur√°vel`,
    
    PICOT: `PICOT - PICO com elemento temporal:
- P (Popula√ß√£o/Paciente): Popula√ß√£o espec√≠fica
- I (Interven√ß√£o): Interven√ß√£o terap√™utica
- C (Compara√ß√£o): Comparador ou controle
- O (Desfecho): Desfecho mensur√°vel
- T (Tempo): Per√≠odo de acompanhamento`,
    
    PICOS: `PICOS - PICO com desenho do estudo:
- P (Popula√ß√£o/Paciente): Popula√ß√£o do estudo
- I (Interven√ß√£o): Interven√ß√£o avaliada
- C (Compara√ß√£o): Comparador
- O (Desfecho): Desfecho
- S (Desenho do Estudo): Tipo de estudo`,
    
    PEO: `PEO - Framework para estudos observacionais:
- P (Popula√ß√£o): Popula√ß√£o exposta
- E (Exposi√ß√£o): Exposi√ß√£o natural/ocupacional
- O (Desfecho): Desfecho observado`,
    
    PECO: `PECO - PEO com compara√ß√£o:
- P (Popula√ß√£o): Popula√ß√£o do estudo
- E (Exposi√ß√£o): Exposi√ß√£o ambiental
- C (Compara√ß√£o): Grupo n√£o exposto
- O (Desfecho): Desfecho observado`,
    
    PCC: `PCC - Framework para revis√µes de escopo:
- P (Popula√ß√£o): Popula√ß√£o de interesse
- C (Conceito): Conceito central explorado
- C2 (Contexto): Contexto geogr√°fico/cultural`,
    
    SPIDER: `SPIDER - Framework para pesquisa qualitativa:
- S (Amostra): Amostra do estudo
- PI (Fen√¥meno de Interesse): Experi√™ncia estudada
- D (Design): M√©todo qualitativo
- E (Avalia√ß√£o): O que est√° sendo avaliado
- R (Tipo de Pesquisa): Tipo de pesquisa qualitativa`,
    
    PIRD: `PIRD - Framework para estudos diagn√≥sticos:
- P (Popula√ß√£o): Popula√ß√£o com suspeita diagn√≥stica
- I (Teste √çndice): Novo teste diagn√≥stico
- R (Teste de Refer√™ncia): Teste padr√£o-ouro
- D (Diagn√≥stico): Condi√ß√£o diagnosticada`,
    
    CoCoPop: `CoCoPop - Framework para estudos de preval√™ncia:
- Co (Condi√ß√£o): Doen√ßa/condi√ß√£o de sa√∫de
- Co2 (Contexto): Contexto temporal/geogr√°fico
- Pop (Popula√ß√£o): Popula√ß√£o estudada`,
    
    SPICE: `SPICE - Framework para avalia√ß√£o de servi√ßos:
- S (Ambiente): Local do servi√ßo de sa√∫de
- P (Perspectiva): Perspectiva dos usu√°rios
- I (Interven√ß√£o): Mudan√ßa no servi√ßo
- C (Compara√ß√£o): Pr√°tica atual
- E (Avalia√ß√£o): Indicadores de qualidade`,
    
    ECLIPSE: `ECLIPSE - Framework para pol√≠ticas de sa√∫de:
- E (Expectativa): Objetivo da pol√≠tica
- C (Grupo de Clientes): Grupo benefici√°rio
- L (Local): Local de implementa√ß√£o
- I (Impacto): Impacto esperado
- P (Profissionais): Profissionais envolvidos
- SE (Servi√ßo): Tipo de servi√ßo`,
    
    BeHEMoTh: `BeHEMoTh - Framework para comportamento em sa√∫de:
- Be (Comportamento): Comportamento de sa√∫de
- HE (Contexto de Sa√∫de): Contexto/ambiente
- Mo (Exclus√µes): Exclus√µes metodol√≥gicas
- Th (Teorias): Teorias comportamentais`
  };

  const prompt = `Voc√™ √© um especialista em extra√ß√£o de conceitos m√©dicos para busca na base DeCS (Descritores em Ci√™ncias da Sa√∫de). Sua tarefa √© analisar elementos de frameworks de pesquisa e extrair conceitos que existem no vocabul√°rio DeCS.

üéØ FRAMEWORK ATUAL: ${frameworkType}

üìö DEFINI√á√ÉO DOS ELEMENTOS:
${frameworkDefinitions[frameworkType] || 'Framework n√£o definido'}

‚ö†Ô∏è REGRAS CR√çTICAS:
1. Cada conceito DEVE estar DIRETAMENTE relacionado ao elemento espec√≠fico
2. N√ÉO misturar conceitos entre elementos diferentes
3. Preferir termos simples e diretos
4. Incluir conceitos em portugu√™s, espanhol e ingl√™s quando poss√≠vel
5. Retornar 5-7 conceitos por elemento

üéØ ELEMENTOS A PROCESSAR:
${JSON.stringify(frameworkElements, null, 2)}

üìù PERGUNTA COMPLETA PARA CONTEXTO:
${fullQuestion}

RETORNE APENAS um objeto JSON com:
- As MESMAS chaves fornecidas em frameworkElements
- Cada chave com array de 5-7 termos relevantes
- Termos em portugu√™s, ingl√™s e espanhol quando poss√≠vel
- Conceitos DIRETAMENTE relacionados ao elemento

RETORNE APENAS O JSON, SEM EXPLICA√á√ïES.`;

  return prompt;
}

// Fun√ß√£o para extrair conceitos usando DeepSeek
async function extractConcepts(frameworkElements, fullQuestion, frameworkType) {
  console.log('ü§ñ Extraindo conceitos para DeCS com DeepSeek');
  
  const prompt = generatePrompt(frameworkElements, fullQuestion, frameworkType);

  try {
    const response = await axios.post(
      'https://api.deepseek.com/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { 
            role: 'system', 
            content: 'Voc√™ √© um especialista em extra√ß√£o de conceitos m√©dicos para busca no DeCS. Extraia termos simples e diretos em portugu√™s, ingl√™s e espanhol quando poss√≠vel.' 
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.1,
        max_tokens: 2000,
        response_format: { type: "json_object" }
      },
      {
        headers: {
          'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 59000
      }
    );

    const concepts = JSON.parse(response.data.choices[0].message.content);
    console.log('‚úÖ Conceitos extra√≠dos:', concepts);
    
    return concepts;
  } catch (error) {
    console.error('‚ùå Erro ao extrair conceitos:', error);
    
    // Fallback: usar os pr√≥prios textos como conceitos
    const fallbackConcepts = {};
    Object.entries(frameworkElements).forEach(([elem, texto]) => {
      fallbackConcepts[elem] = [texto];
    });
    
    return fallbackConcepts;
  }
}

// Fun√ß√£o para buscar termos DeCS
async function searchDeCSTerms(searchTerm, language = 'pt') {
  console.log(`üîç Buscando DeCS: "${searchTerm}" (${language})`);
  
  try {
    // Delay entre requisi√ß√µes
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Busca por palavras
    const searchUrl = `${DECS_BASE_URL}/search-by-words`;
    const searchParams = {
      words: searchTerm,
      lang: language,
      format: 'json'
    };
    
    console.log(`üì° Chamando API DeCS...`);
    
    const response = await axios.get(searchUrl, {
      params: searchParams,
      headers: {
        'Authorization': `Bearer ${DECS_API_KEY}`,
        'Content-Type': 'application/json'
      },
      timeout: 59000
    });
    
    const results = [];
    
    // Processar resposta do DeCS
    if (response.data && response.data.decs) {
      const decsData = response.data.decs;
      
      // DeCS retorna um objeto com descritores
      if (decsData.descriptors && Array.isArray(decsData.descriptors)) {
        decsData.descriptors.forEach((descriptor, index) => {
          // Extrair informa√ß√µes multil√≠ngues
          const terms = {
            pt: descriptor.descriptor_pt || '',
            es: descriptor.descriptor_es || '',
            en: descriptor.descriptor_en || '',
            fr: descriptor.descriptor_fr || ''
          };
          
          // Defini√ß√µes multil√≠ngues
          const definitions = {
            pt: descriptor.definition_pt || '',
            es: descriptor.definition_es || '',
            en: descriptor.definition_en || '',
            fr: descriptor.definition_fr || ''
          };
          
          // Sin√¥nimos
          const synonyms = {
            pt: descriptor.synonyms_pt || [],
            es: descriptor.synonyms_es || [],
            en: descriptor.synonyms_en || [],
            fr: descriptor.synonyms_fr || []
          };
          
          // Tree numbers (hierarquia)
          const treeNumbers = descriptor.tree_numbers || [];
          
          // Calcular relev√¢ncia
          const relevanceScore = Math.round(95 - (index * 2));
          
          results.push({
            decsId: descriptor.decs_code || descriptor.id || `decs_${index}`,
            terms: terms,
            definitions: definitions,
            synonyms: synonyms,
            treeNumbers: treeNumbers,
            relevanceScore: relevanceScore,
            language: language
          });
        });
      }
    }
    
    console.log(`‚úÖ ${results.length} termos DeCS encontrados`);
    return results;
    
  } catch (error) {
    console.error(`‚ùå Erro ao buscar DeCS:`, error.message);
    return [];
  }
}

// Fun√ß√£o alternativa para busca booleana se a busca por palavras falhar
async function searchDeCSBoolean(searchTerm, language = 'pt') {
  console.log(`üîç Tentando busca booleana DeCS: "${searchTerm}" (${language})`);
  
  try {
    const searchUrl = `${DECS_BASE_URL}/search-boolean`;
    const searchParams = {
      bool: searchTerm,
      lang: language,
      format: 'json'
    };
    
    const response = await axios.get(searchUrl, {
      params: searchParams,
      headers: {
        'Authorization': `Bearer ${DECS_API_KEY}`,
        'Content-Type': 'application/json'
      },
      timeout: 59000
    });
    
    const results = [];
    
    if (response.data && response.data.decs && response.data.decs.descriptors) {
      response.data.decs.descriptors.forEach((descriptor, index) => {
        const terms = {
          pt: descriptor.descriptor_pt || '',
          es: descriptor.descriptor_es || '',
          en: descriptor.descriptor_en || '',
          fr: descriptor.descriptor_fr || ''
        };
        
        const definitions = {
          pt: descriptor.definition_pt || '',
          es: descriptor.definition_es || '',
          en: descriptor.definition_en || '',
          fr: descriptor.definition_fr || ''
        };
        
        const relevanceScore = Math.round(90 - (index * 2));
        
        results.push({
          decsId: descriptor.decs_code || `decs_${index}`,
          terms: terms,
          definitions: definitions,
          synonyms: {},
          treeNumbers: descriptor.tree_numbers || [],
          relevanceScore: relevanceScore,
          language: language
        });
      });
    }
    
    return results;
    
  } catch (error) {
    console.error(`‚ùå Erro na busca booleana:`, error.message);
    return [];
  }
}

// Handler principal
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  res.setHeader('Content-Type', 'application/json; charset=utf-8');

  console.log('\nüöÄ API DeCS - IN√çCIO DO PROCESSAMENTO');
  console.log('===================================================');
  console.log('üì• Dados recebidos:', JSON.stringify(req.body, null, 2));

  const { frameworkElements, fullQuestion, frameworkType } = req.body;

  // Filtrar elementos v√°lidos
  const validFrameworkElements = filterValidFrameworkElements(frameworkElements, frameworkType);
  console.log('‚úÖ Elementos v√°lidos:', validFrameworkElements);

  try {
    const processStartTime = Date.now();
    
    // PASSO 1: Extrair conceitos usando IA
    console.log('\nü§ñ PASSO 1: EXTRA√á√ÉO DE CONCEITOS');
    const concepts = await extractConcepts(validFrameworkElements, fullQuestion, frameworkType);
    
    // PASSO 2: Buscar termos DeCS
    console.log('\nüîé PASSO 2: BUSCA DE TERMOS DECS');
    
    const results = [];
    const allDecsTerms = [];
    const languages = ['pt', 'es', 'en']; // Portugu√™s, Espanhol, Ingl√™s
    
    // Processar cada elemento
    for (const [element, originalText] of Object.entries(validFrameworkElements)) {
      console.log(`\nüìå Processando elemento: ${element} - "${originalText}"`);
      
      const elementResults = {
        element,
        originalText: originalText,
        terms: []
      };
      
      // Obter conceitos para este elemento
      const elementConcepts = concepts[element] || [originalText];
      
      // Para cada conceito, buscar em m√∫ltiplos idiomas
      for (const searchTerm of elementConcepts) {
        for (const lang of languages) {
          try {
            // Tentar busca por palavras primeiro
            let decsTerms = await searchDeCSTerms(searchTerm, lang);
            
            // Se n√£o encontrar, tentar busca booleana
            if (decsTerms.length === 0) {
              decsTerms = await searchDeCSBoolean(searchTerm, lang);
            }
            
            // Adicionar termos encontrados
            decsTerms.forEach(term => {
              // Verificar se j√° n√£o foi adicionado
              if (!elementResults.terms.find(t => t.decsId === term.decsId)) {
                elementResults.terms.push(term);
                allDecsTerms.push(term);
              }
            });
            
          } catch (error) {
            console.error(`‚ùå Erro ao buscar "${searchTerm}" em ${lang}:`, error.message);
          }
        }
      }
      
      // Ordenar por relev√¢ncia
      elementResults.terms.sort((a, b) => b.relevanceScore - a.relevanceScore);
      
      // Limitar a 10 termos por elemento
      elementResults.terms = elementResults.terms.slice(0, 10);
      
      results.push(elementResults);
      console.log(`‚úÖ Elemento ${element}: ${elementResults.terms.length} termos DeCS encontrados`);
    }

    // Remover duplicatas globais
    const uniqueDecsTerms = allDecsTerms
      .filter((term, index, self) => 
        index === self.findIndex(t => t.decsId === term.decsId))
      .filter(term => term.relevanceScore >= 50);

    const processTime = Date.now() - processStartTime;
    
    // LOG FINAL
    console.log('\nüìä RESUMO FINAL');
    console.log(`‚è±Ô∏è Tempo total: ${(processTime/1000).toFixed(2)}s`);
    console.log(`‚úÖ Elementos processados: ${results.length}`);
    console.log(`üéØ Total de termos √∫nicos: ${uniqueDecsTerms.length}`);

    // Preparar resposta
    const responseData = {
      results,
      allDecsTerms: uniqueDecsTerms,
      processTime: processTime
    };
    
    console.log('üì§ Enviando resposta...');
    res.status(200).json(responseData);
    
  } catch (error) {
    console.error('‚ùå ERRO GERAL:', error);
    res.status(500).json({ 
      error: 'Erro ao buscar termos DeCS',
      details: error.message
    });
  }
}